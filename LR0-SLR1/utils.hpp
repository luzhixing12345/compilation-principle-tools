/*
 *Copyright (c) 2022 All rights reserved
 *@description: basic data structure for LR0 and SLR1
 *@author: Zhixing Lu
 *@date: 2022-06-05
 *@email: luzhixing12345@163.com
 *@Github: luzhixing12345
*/


#ifndef LR0_SLR1_UTILS_HPP_
#define LR0_SLR1_UTILS_HPP_

#include "../utils.hpp"


struct Item {
    char left;
    int dot_pos;
    std::string right;
};

class Closure {
public:
    Closure(int state_num, Item &item) {
        this->state_num = state_num;
        this->items.push_back(item);
    }
    void calculateClosure(RuleSet &rule_set) {
        // calculate the closure of the item
        // the closure is the set of all items that can be generated by the item
        
        for (int i = 0; i < this->items.size(); i++) {
            Item item = items[i];
            if (item.dot_pos == item.right.size()) {
                // the item is already in the closure
                continue;
            } else if (isTerminal(item.right[item.dot_pos],rule_set.non_terminal_set)) {
                // terminal symbol has no expansion
                continue;
            } else {
                // non-terminal symbol has expansion
                char non_terminal = item.right[item.dot_pos];
                for (int j = 0; j < rule_set.rules.size(); j++) {
                    Rule rule = rule_set.rules[j];
                    if (rule.first == non_terminal) {
                        // the rule is applicable
                        Item new_item;
                        new_item.left = rule.first;
                        new_item.right = rule.second;
                        new_item.dot_pos = 0;
                        // check if the new item is already in the closure
                        bool is_in_closure = false;
                        for (int k = 0; k < this->items.size(); k++) {
                            if (this->items[k].left == new_item.left && this->items[k].right == new_item.right && this->items[k].dot_pos == new_item.dot_pos) {
                                is_in_closure = true;
                                break;
                            }
                        }
                        if (!is_in_closure) this->items.push_back(new_item);
                    }
                }
            }
        }
    };
private:
    bool SR_collapse; // shift reduce collapse
    bool RR_collapse; // reduce reduce collapse
    int state_num;
    std::vector<Item> items;
    std::vector<int> shift_items;
    std::vector<int> reduce_items;

    std::vector<std::pair<char,Closure*>> goto_table;

};

class Graph {
public:
    Graph(){
        this->state_num = 0;
        this->start_symbol = "START";
    };
    void createNewClosure(Item &item){
        Closure clousure = Closure(this->state_num, item);
        this->closures.push_back(clousure);
        this->state_num++;
    };
private:
    int state_num;
    std::string start_symbol;
    std::vector<Closure> closures;
};


#endif // LR0_SLR1_UTILS_HPP_
